<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.1"
             xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                                   http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">  

	<persistence-unit name="ConztanzPersistenceUnitPrimary" transaction-type="JTA">
	
		<!-- Persistence Provider -->
		<provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
<!-- 		<provider>org.hibernate.ejb.HibernatePersistence</provider> -->
		<!--DataSource look up via JNDI  -->
		<jta-data-source>osgi:service/javax.sql.DataSource/(osgi.jndi.service.name=ConztanzDB)</jta-data-source>
		
		<!-- Entity Definition & Persistence Specificity -->   
		<exclude-unlisted-classes>true</exclude-unlisted-classes>
		
		
		<!-- Hibernate / Database bridge settings -->
		<properties>            
			<!-- JDBC Database Connection settings -->
			<!-- In JTA environment, literature says it should be defined as auto (or after_statement)
			     so that hibernate aggressively release the connection after each statement. But the
			     XADataSource used will instantly make it available to other hibernate sessions which
			     would mix up transactions and connections as explain below:
			
			        Transaction  start as T1
			        Session start as S1
			        S1 borrow a connection C1 from the XADataSource
			        T1 start on C1
			        S1 execute the statement on C1
			        S1 give back C1 to the XADataSource (T1 still active on C1)
			        
			           Transaction  start as T2
			           Session start as S2
			           S2 borrow a connection C1 from the XADataSource
			           T2 start on C1 ...... EXCEPTION !!!
			#######################################################################################
			     This problem does not exist anymore as JTA process was tweaked to only release the
			     connection to the pool when not anymore relying on an active transaction.
			     Above comments are just left to explained problems that could occur when mixing JTA
			     and connection pools
			-->
			<property name="hibernate.connection.release_mode"   value="auto"/>
		
			<!-- Hibernate SQL Dialect setting -->
			<!-- As hibernate does not yet support JSONB PostgreSQL field, it has to be internally extended -->
			<property name="hibernate.dialect" value="com.conztanz.persistence.dialect.PostgreSQLConztanzDialect"/>
<!-- 			<property name="hibernate.temp.use_jdbc_metadata_defaults" value="false"/> -->
		
			<!-- Transaction setting -->
			<property name="hibernate.current_session_context_class" value="jta"/>
			<property name="hibernate.transaction.jta.platform"      value="com.conztanz.persistence.jta.ConztanzJtaPlatform"/>
		
			<!-- Batch size settings -->
			<property name="hibernate.jdbc.batch_size" value="25"/>
			<!-- Allow optimal batch and reduce dead-lock probability -->
			<property name="hibernate.order_inserts" value="true"/>
			<property name="hibernate.order_updates" value="true"/>
<!-- 			<property name="hibernate.max_fetch_depth"       value="4"/> -->
<!-- 			<property name="hibernate.generate_statistics"   value="true"/> -->

<!-- 			<property name="javax.persistence.query.timeout" value="10"/> -->
		
			<!-- SQL Log settings -->
			<property name="hibernate.show_sql"         value="true"/>
			<property name="hibernate.format_sql"       value="true"/>
			<property name="hibernate.use_sql_comments" value="false"/>
			
<!-- 			<property name="jadira.usertype.databaseZone" value="UTC"/> -->
<!-- 			<property name="jadira.usertype.javaZone"     value="UTC"/> -->
		
			<!-- 2nd level cache settings -->
<!-- 			<property name="hibernate.cache.use_second_level_cache" value="true"/> -->
<!-- 			<property name="hibernate.cache.use_query_cache"        value="false"/> -->
<!-- 			<property name="hibernate.cache.region.factory_class"   value="org.hibernate.cache.infinispan.InfinispanRegionFactory"/> -->
<!-- 			<property name="hibernate.cache.use_structured_entries" value="true"/> -->
		</properties>
	</persistence-unit>
</persistence>